{
  "swagger": "2.0",
  "info": {
    "title": "Stanza Hub API",
    "version": "1.0",
    "contact": {
      "name": "Stanza",
      "url": "https://stanza.systems",
      "email": "support@stanza.systems"
    }
  },
  "tags": [
    {
      "name": "AuthService"
    },
    {
      "name": "ConfigService"
    },
    {
      "name": "HealthService"
    },
    {
      "name": "QuotaService"
    }
  ],
  "schemes": [
    "https"
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/v1/auth/token": {
      "get": {
        "summary": "Returns a Bearer Token if your API key is valid.",
        "description": "Inspects the X-Stanza-Key auth header and returns a new Bearer Token if valid.",
        "operationId": "AuthService_GetBearerToken",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1GetBearerTokenResponse"
            }
          },
          "429": {
            "description": "Too Many Requests, try again after Retry-After.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "500": {
            "description": "Internal Server Error",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "503": {
            "description": "Service Unavailable, try again after Retry-After.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "tags": [
          "AuthService"
        ]
      }
    },
    "/v1/config/decorator": {
      "post": {
        "summary": "Get decorator config",
        "description": "Get decorator config from Stanza Hub.",
        "operationId": "ConfigService_GetDecoratorConfig",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1GetDecoratorConfigResponse"
            }
          },
          "429": {
            "description": "Too Many Requests, try again after Retry-After.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "500": {
            "description": "Internal Server Error",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "503": {
            "description": "Service Unavailable, try again after Retry-After.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "GetDecoratorConfigRequest is the request from Backend SDKs to Hub for an decorator's config. SDKs are expected to periodically poll, giving the version of the most recent configuration seen/. Configurations may be large; we will not re-send them unless they have changed. Decorator configurations may vary between envs. Decorator configurations are SHARED between Services, but may be overridden for specific Services.\n\nRequired Header: X-Stanza-Key",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1GetDecoratorConfigRequest"
            }
          }
        ],
        "tags": [
          "ConfigService"
        ]
      }
    },
    "/v1/config/service": {
      "post": {
        "summary": "Get service config",
        "description": "Get service config from Stanza Hub.",
        "operationId": "ConfigService_GetServiceConfig",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1GetServiceConfigResponse"
            }
          },
          "429": {
            "description": "Too Many Requests, try again after Retry-After.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "500": {
            "description": "Internal Server Error",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "503": {
            "description": "Service Unavailable, try again after Retry-After.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "GetServiceConfigRequest is the request from Backend SDKs to Hub for a service config. SDKs are expected to periodically poll, giving the version of the most recent configuration seen. Configurations may be large; we will not re-send them unless they have changed.\n\nRequired Header: X-Stanza-Key",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1GetServiceConfigRequest"
            }
          }
        ],
        "tags": [
          "ConfigService"
        ]
      }
    },
    "/v1/context/browser": {
      "post": {
        "summary": "Get browser context",
        "description": "Get browser context from Stanza Hub.",
        "operationId": "ConfigService_GetBrowserContext",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1GetBrowserContextResponse"
            },
            "headers": {
              "Etag": {
                "description": "Unique entity identifier for this specific resource version.",
                "type": "string"
              }
            }
          },
          "304": {
            "description": "OK, Not Modified.",
            "schema": {},
            "headers": {
              "Etag": {
                "description": "Unique entity identifier for this specific resource version.",
                "type": "string"
              }
            }
          },
          "429": {
            "description": "Too Many Requests, try again after Retry-After.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "500": {
            "description": "Internal Server Error",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "503": {
            "description": "Service Unavailable, try again after Retry-After.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "GetBrowserContextRequest is the request from Browser SDKs to Hub for a browser config.\nSDKs are expected to periodically poll, giving the version of the most recent configuration seen.\nConfigurations may be large; we will not re-send them unless they have changed.\nIf no feature_names are specified, all Features belonging to the organisation will be returned.\n\nRequired Header: X-Stanza-Key\nOptional Header: etag",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1GetBrowserContextRequest"
            }
          }
        ],
        "tags": [
          "ConfigService"
        ]
      }
    },
    "/v1/health/decorator": {
      "post": {
        "summary": "Get decorator health information.",
        "description": "Used by SDK to allow developers to make decisions about graceful degradation of backend services.",
        "operationId": "HealthService_QueryDecoratorHealth",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1QueryDecoratorHealthResponse"
            }
          },
          "429": {
            "description": "Too Many Requests, try again after Retry-After.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "500": {
            "description": "Internal Server Error",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "503": {
            "description": "Service Unavailable, try again after Retry-After.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "Called by SDK to determine whether a Decorator is overloaded at a given Feature's priority level. Used so that customer code can make good decisions about fail-fast or graceful degradation as high up the stack as possible. SDK may cache the result for up to 10 seconds.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1QueryDecoratorHealthRequest"
            }
          }
        ],
        "tags": [
          "HealthService"
        ]
      }
    },
    "/v1/quota/consumed": {
      "post": {
        "summary": "Inform stanza that quota tokens were consumed",
        "description": "Inform stanza that one or more quota tokens were consumed.",
        "operationId": "QuotaService_SetTokenLeaseConsumed",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1SetTokenLeaseConsumedResponse"
            }
          },
          "429": {
            "description": "Too Many Requests, try again after Retry-After.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "500": {
            "description": "Internal Server Error",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "503": {
            "description": "Service Unavailable, try again after Retry-After.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "Notifies Hub that one or more token leases has been used, i.e. decorator has been exercised.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1SetTokenLeaseConsumedRequest"
            }
          }
        ],
        "tags": [
          "QuotaService"
        ]
      }
    },
    "/v1/quota/lease": {
      "post": {
        "summary": "Get one or more access token leases",
        "description": "Get a set of token leases from Stanza Hub for access to given Decorator (optional Feature name for priority).",
        "operationId": "QuotaService_GetTokenLease",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1GetTokenLeaseResponse"
            }
          },
          "429": {
            "description": "Too Many Requests, try again after Retry-After.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "500": {
            "description": "Internal Server Error",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "503": {
            "description": "Service Unavailable, try again after Retry-After.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "Requests token lease for given decorator at priority of specified feature.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1GetTokenLeaseRequest"
            }
          }
        ],
        "tags": [
          "QuotaService"
        ]
      }
    },
    "/v1/quota/token": {
      "post": {
        "summary": "Get an access token",
        "description": "Get a token from Stanza Hub for access to given Decorator (optional Feature name for priority).",
        "operationId": "QuotaService_GetToken",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1GetTokenResponse"
            }
          },
          "429": {
            "description": "Too Many Requests, try again after Retry-After.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "500": {
            "description": "Internal Server Error",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "503": {
            "description": "Service Unavailable, try again after Retry-After.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "Requests token for given decorator at priority of specified feature.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1GetTokenRequest"
            }
          }
        ],
        "tags": [
          "QuotaService"
        ]
      }
    },
    "/v1/quota/validatetokens": {
      "post": {
        "summary": "Validate one or more tokens",
        "description": "Validate one or more tokens.",
        "operationId": "QuotaService_ValidateToken",
        "responses": {
          "200": {
            "description": "OK",
            "schema": {
              "$ref": "#/definitions/v1ValidateTokenResponse"
            }
          },
          "429": {
            "description": "Too Many Requests, try again after Retry-After.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "500": {
            "description": "Internal Server Error",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "503": {
            "description": "Service Unavailable, try again after Retry-After.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "Calls Hub to validate a token (ensures token has not expired, was minted by Hub, and related to the specified Decorator). Used from Ingress decorators. Ensures callers have acquired quota prior to expending resources.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1ValidateTokenRequest"
            }
          }
        ],
        "tags": [
          "QuotaService"
        ]
      }
    }
  },
  "definitions": {
    "hubv1Tag": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string"
        },
        "value": {
          "type": "string"
        }
      }
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string"
        }
      },
      "additionalProperties": {}
    },
    "rpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "v1BrowserConfig": {
      "type": "object",
      "properties": {
        "enabledPercent": {
          "type": "integer",
          "format": "int64"
        },
        "actionCodeEnabled": {
          "type": "integer",
          "format": "int64"
        },
        "messageEnabled": {
          "type": "string"
        },
        "actionCodeDisabled": {
          "type": "integer",
          "format": "int64"
        },
        "messageDisabled": {
          "type": "string"
        }
      },
      "description": "BrowserConfig describes the current configuration for one Feature.\nInstead of being simply enabled or disabled, features are enabled for a\nparticular percentage of clients (0% is entirely disabled, 100% is entirely enabled).\nClients are required to self-select a percentile value from 1 to 100 in a way that is random\nand trusted to consider a Feature disabled if it is disabled for the selected percentile.\naction_code_disabled describes what the Browser is expected to do if the Feature is not enabled for\ntheir assigned percentile.\nmessage_disabled may be displayed as a fallback action.\naction_code_enabled describes what the Browser is expected to do if the Feature is enabled for\ntheir assigned percentile. This enabled degraded modes. Can be empty.\nmessage_enabled may be displayed while in degraded mode. Can be empty.\nLikely additional fields will be added here as the Browser SDK behavior set becomes more complex."
    },
    "v1DecoratorConfig": {
      "type": "object",
      "properties": {
        "validateIngressTokens": {
          "type": "boolean",
          "description": "Boolean representing wether to validate contents of the X-Stanza-Token header."
        },
        "checkQuota": {
          "type": "boolean",
          "description": "Boolean representing whether quota checks are enabled.",
          "title": "Quota"
        },
        "quotaTags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The set of tags which are used for quota management. For example, a 'customer_id' tag might be used to implement per-customer quota limits. Only the tags listed here should be included in GetToken and GetTokenLease requests."
        },
        "traceConfig": {
          "$ref": "#/definitions/v1TraceConfig",
          "title": "OTEL"
        },
        "metricConfig": {
          "$ref": "#/definitions/v1MetricConfig"
        }
      },
      "description": "DecoratorConfig represents a configuration for a given Stanza SDK instrumented Decorator, which may be used by multiple services!\nIf trace_config is empty, no per-decorator trace configuration is applied. Service-level trace configuration will be used (if applicable).\nIf check_quota is false, then no ratelimiting will be performed. All quota requests will succeed and the SDK may short-circuit quota requests, i.e. not call Hub for quota.\nAt a later point (post V0), there will be additional per-decorator configuration, such as deadline overrides, adaptive circuitbreaking configs, etc."
    },
    "v1DecoratorFeatureSelector": {
      "type": "object",
      "properties": {
        "environment": {
          "type": "string"
        },
        "decoratorName": {
          "type": "string"
        },
        "featureName": {
          "type": "string"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/hubv1Tag"
          }
        }
      },
      "required": [
        "environment",
        "decoratorName"
      ]
    },
    "v1DecoratorSelector": {
      "type": "object",
      "properties": {
        "environment": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/hubv1Tag"
          }
        }
      },
      "required": [
        "environment",
        "name"
      ]
    },
    "v1DecoratorServiceSelector": {
      "type": "object",
      "properties": {
        "environment": {
          "type": "string"
        },
        "decoratorName": {
          "type": "string"
        },
        "serviceName": {
          "type": "string"
        },
        "serviceRelease": {
          "type": "string"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/hubv1Tag"
          }
        }
      },
      "required": [
        "environment",
        "decoratorName",
        "serviceName",
        "serviceRelease"
      ]
    },
    "v1FeatureConfig": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "config": {
          "$ref": "#/definitions/v1BrowserConfig"
        }
      }
    },
    "v1FeatureSelector": {
      "type": "object",
      "properties": {
        "environment": {
          "type": "string"
        },
        "names": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/hubv1Tag"
          }
        }
      },
      "required": [
        "environment"
      ]
    },
    "v1GetBearerTokenResponse": {
      "type": "object",
      "properties": {
        "bearerToken": {
          "type": "string"
        }
      },
      "description": "GetBearerTokenResponse is a new Bearer Token."
    },
    "v1GetBrowserContextRequest": {
      "type": "object",
      "properties": {
        "feature": {
          "$ref": "#/definitions/v1FeatureSelector",
          "description": "Information required to select and return the most recent BrowserContext version. If Feature names is nil, will return all Features in the organisation associated with the bearer token/API key, otherwise only information related to the named Features will be returned."
        }
      },
      "description": "GetBrowserContextRequest is the request from Browser SDKs to Hub for a browser config.\nSDKs are expected to periodically poll, giving the version of the most recent configuration seen.\nConfigurations may be large; we will not re-send them unless they have changed.\nIf no feature_names are specified, all Features belonging to the organisation will be returned.\n\nRequired Header: X-Stanza-Key\nOptional Header: etag"
    },
    "v1GetBrowserContextResponse": {
      "type": "object",
      "properties": {
        "featureConfigs": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1FeatureConfig"
          }
        }
      },
      "description": "GetBrowserConfigResponse is the response from Hub to Browser SDKs. It is designed to be cacheable for short periods. It is also designed to be shareable between multiple clients (e.g. in case of SSR or use of CDN etc).\n\nReturns etag header.\n\nMay return 304 Not Modified with etag header and empty payload."
    },
    "v1GetDecoratorConfigRequest": {
      "type": "object",
      "properties": {
        "versionSeen": {
          "type": "string",
          "description": "Set if the client has seen a previous version of the config. Server will send data only if newer config available."
        },
        "selector": {
          "$ref": "#/definitions/v1DecoratorServiceSelector",
          "description": "Information required to select and return the correct DecoratorConfig version."
        }
      },
      "description": "GetDecoratorConfigRequest is the request from Backend SDKs to Hub for an decorator's config. SDKs are expected to periodically poll, giving the version of the most recent configuration seen/. Configurations may be large; we will not re-send them unless they have changed. Decorator configurations may vary between envs. Decorator configurations are SHARED between Services, but may be overridden for specific Services.\n\nRequired Header: X-Stanza-Key"
    },
    "v1GetDecoratorConfigResponse": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string"
        },
        "configDataSent": {
          "type": "boolean"
        },
        "config": {
          "$ref": "#/definitions/v1DecoratorConfig"
        }
      },
      "description": "GetDecoratorConfigResponse is the response from Hub to Backend SDKs.\nNote that `config_data_sent` will be false and `config` will be empty if we did not have a newer config\nversion than `version_seen`."
    },
    "v1GetServiceConfigRequest": {
      "type": "object",
      "properties": {
        "versionSeen": {
          "type": "string",
          "description": "Set if the client has seen a previous version of the config. Server will send data only if newer config available."
        },
        "service": {
          "$ref": "#/definitions/v1ServiceSelector",
          "title": "Information required to select and return the most recent ServiceConfig version"
        }
      },
      "description": "GetServiceConfigRequest is the request from Backend SDKs to Hub for a service config. SDKs are expected to periodically poll, giving the version of the most recent configuration seen. Configurations may be large; we will not re-send them unless they have changed.\n\nRequired Header: X-Stanza-Key"
    },
    "v1GetServiceConfigResponse": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string"
        },
        "configDataSent": {
          "type": "boolean"
        },
        "config": {
          "$ref": "#/definitions/v1ServiceConfig"
        }
      },
      "description": "GetServiceConfigResponse is the response from Hub to Backend SDKs. Note that `config_data_sent` will be false and `config` will be empty if we did not have a newer config version than `version_seen`."
    },
    "v1GetTokenLeaseRequest": {
      "type": "object",
      "properties": {
        "s": {
          "$ref": "#/definitions/v1DecoratorFeatureSelector",
          "description": "Only tags which are used for quota management should be included here - i.e. the list of quota_tags returned by the GetDecoratorConfig endpoint for this Decorator. If tags are in use only one quota token will be issued at a time."
        },
        "clientId": {
          "type": "string",
          "description": "Used for tracking per-client token usage, allowing automatic determination of efficient batch leases. ID should be assigned by Stanza clients and be unique per-customer. Host or instance names may be used, or a UUID."
        },
        "priorityBoost": {
          "type": "integer",
          "format": "int32",
          "description": "Used to boost priority - SDK can increase or decrease priority of request, relative to normal feature priority. For instance, a customer may wish to boost the priority of paid user traffic over free tier. Priority boosts may also be negative - for example, one might deprioritise bot traffic."
        },
        "defaultWeight": {
          "type": "number",
          "format": "float",
          "description": "Used for request weighting, i.e. accounting for varying request sizes and costs. The value set here is the default request weight which should be assumed for leases. If not specified, then the median weight is used when granted leases. Actual weights should be set via the SetTokenLeaseConsumed rpc.\n\ndefault_weight is optional; if not used then it is assumed that all requests have weight of 1."
        }
      },
      "description": "Requests token lease for given decorator at priority of specified feature."
    },
    "v1GetTokenLeaseResponse": {
      "type": "object",
      "properties": {
        "leases": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1TokenLease"
          }
        }
      },
      "title": "Specifies tokens granted and their duration (may be empty if none granted)"
    },
    "v1GetTokenRequest": {
      "type": "object",
      "properties": {
        "selector": {
          "$ref": "#/definitions/v1DecoratorFeatureSelector",
          "description": "Only tags which are used for quota management should be included here - i.e. the list of quota_tags returned by the GetDecoratorConfig endpoint for this Decorator. If tags are in use only one quota token will be issued at a time."
        },
        "clientId": {
          "type": "string",
          "description": "Used for tracking per-client token usage, allowing automatic determination of efficient batch leases. ID should be assigned by Stanza clients and be unique per-customer. Host or instance names may be used, or a UUID."
        },
        "priorityBoost": {
          "type": "integer",
          "format": "int32",
          "description": "Used to increase or decrease priority of request, relative to normal feature priority."
        },
        "weight": {
          "type": "number",
          "format": "float",
          "description": "Used for request weighting, i.e. accounting for varying request sizes and costs. If not specified then a default value of 1 is used. In cases where weights/costs are not known upfront, users can send an initial estimate as the weight, and then later, when the exact cost is known, send an updated weight via the SetTokenLeaseConsumed rpc.\n\nweight is optional; if not used then it is assumed that all requests have weight of 1."
        }
      },
      "description": "Requests token for given decorator at priority of specified feature."
    },
    "v1GetTokenResponse": {
      "type": "object",
      "properties": {
        "granted": {
          "type": "boolean"
        },
        "token": {
          "type": "string"
        },
        "reason": {
          "$ref": "#/definitions/v1Reason"
        }
      },
      "description": "Specifies whether token granted."
    },
    "v1HeaderTraceConfig": {
      "type": "object",
      "properties": {
        "spanSelectors": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1SpanSelector"
          },
          "title": "If no selectors specified then config is applied to all requests"
        },
        "requestHeaderNames": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Names of headers to collect"
        },
        "responseHeaderNames": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Names of headers to collect"
        }
      },
      "description": "Specifies which headers should be sampled - required by OTel spec."
    },
    "v1Health": {
      "type": "string",
      "enum": [
        "HEALTH_OK",
        "HEALTH_OVERLOAD",
        "HEALTH_DOWN"
      ]
    },
    "v1MetricConfig": {
      "type": "object",
      "properties": {
        "collectorUrl": {
          "type": "string",
          "title": "url of OTEL collector - grpc"
        },
        "collectorKey": {
          "type": "string",
          "title": "send as x-stanza-key header"
        },
        "collectorUrlHttp": {
          "type": "string",
          "title": "url of OTEL collector - HTTP"
        }
      }
    },
    "v1ParamTraceConfig": {
      "type": "object",
      "properties": {
        "spanSelectors": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1SpanSelector"
          },
          "title": "If no selectors specified then config is applied to all requests"
        },
        "parameterNames": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Names of parameters to collect"
        }
      },
      "description": "Specifies which request parameters should be sampled."
    },
    "v1QueryDecoratorHealthRequest": {
      "type": "object",
      "properties": {
        "selector": {
          "$ref": "#/definitions/v1DecoratorFeatureSelector",
          "description": "Only tags which are used for quota management should be included here - i.e. the list of quota_tags returned by the GetDecoratorConfig endpoint for this Decorator. If tags are in use only one quota token will be issued at a time.\n\nRequired: decoratorName, featureName, environment"
        },
        "priorityBoost": {
          "type": "integer",
          "format": "int32",
          "description": "Used to boost priority - SDK can increase or decrease priority of request, relative to normal feature priority. For instance, a customer may wish to boost the priority of paid user traffic over free tier. Priority boosts may also be negative - for example, one might deprioritise bot traffic."
        }
      },
      "description": "Called by SDK to determine whether a Decorator is overloaded at a given Feature's priority level. Used so that customer code can make good decisions about fail-fast or graceful degradation as high up the stack as possible. SDK may cache the result for up to 10 seconds."
    },
    "v1QueryDecoratorHealthResponse": {
      "type": "object",
      "properties": {
        "health": {
          "$ref": "#/definitions/v1Health"
        }
      }
    },
    "v1Reason": {
      "type": "string",
      "enum": [
        "REASON_SUFFICIENT_QUOTA",
        "REASON_INSUFFICIENT_QUOTA",
        "REASON_INSUFFICIENT_QUOTA_PARENT",
        "REASON_BURST",
        "REASON_BEST_EFFORT"
      ]
    },
    "v1SentinelConfig": {
      "type": "object",
      "properties": {
        "circuitbreakerRulesJson": {
          "type": "string"
        },
        "flowRulesJson": {
          "type": "string"
        },
        "isolationRulesJson": {
          "type": "string"
        },
        "systemRulesJson": {
          "type": "string"
        }
      },
      "description": "SentinelConfig represents Sentinel compliant JSON configuration for the given Sentinel types. These rules are \"per service\" (not per Decorator) with Decorator specific routing encoded in the given JSON blobs (as Sentinel \"Resources\")."
    },
    "v1ServiceConfig": {
      "type": "object",
      "properties": {
        "traceConfig": {
          "$ref": "#/definitions/v1TraceConfig"
        },
        "metricConfig": {
          "$ref": "#/definitions/v1MetricConfig"
        },
        "sentinelConfig": {
          "$ref": "#/definitions/v1SentinelConfig"
        }
      },
      "description": "ServiceConfig represents a configuration for a given Stanza SDK instrumented service."
    },
    "v1ServiceSelector": {
      "type": "object",
      "properties": {
        "environment": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "release": {
          "type": "string"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/hubv1Tag"
          }
        }
      },
      "required": [
        "environment",
        "name"
      ]
    },
    "v1SetTokenLeaseConsumedRequest": {
      "type": "object",
      "properties": {
        "tokens": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "weightCorrection": {
          "type": "number",
          "format": "float",
          "description": "Used for request weighting, i.e. accounting for varying request sizes and costs. If weights are not known before request execution, then a default or estimated weight may be used, followed by a corrected value here. If a value is sent here, it should be the actual request weight."
        }
      },
      "description": "Notifies Hub that one or more token leases has been used, i.e. decorator has been exercised.",
      "required": [
        "tokens"
      ]
    },
    "v1SetTokenLeaseConsumedResponse": {
      "type": "object",
      "title": "No message contents yet"
    },
    "v1SpanSelector": {
      "type": "object",
      "properties": {
        "otelAttribute": {
          "type": "string",
          "title": "OTel attribute, e.g. peer.service, status, http.status_code. See:\nhttps://opentelemetry.io/docs/reference/specification/trace/semantic_conventions/span-general/\nhttps://opentelemetry.io/docs/reference/specification/trace/semantic_conventions/http/"
        },
        "value": {
          "type": "string",
          "description": "Selector matches if value of 'otel_attribute' equals 'value'."
        }
      }
    },
    "v1TokenInfo": {
      "type": "object",
      "properties": {
        "token": {
          "type": "string"
        },
        "decorator": {
          "$ref": "#/definitions/v1DecoratorSelector"
        }
      },
      "required": [
        "token"
      ]
    },
    "v1TokenLease": {
      "type": "object",
      "properties": {
        "durationMsec": {
          "type": "integer",
          "format": "int32"
        },
        "token": {
          "type": "string"
        },
        "feature": {
          "type": "string"
        },
        "priorityBoost": {
          "type": "integer",
          "format": "int32"
        },
        "weight": {
          "type": "number",
          "format": "float"
        },
        "reason": {
          "$ref": "#/definitions/v1Reason"
        }
      }
    },
    "v1TokenValid": {
      "type": "object",
      "properties": {
        "token": {
          "type": "string"
        },
        "valid": {
          "type": "boolean"
        }
      }
    },
    "v1TraceConfig": {
      "type": "object",
      "properties": {
        "collectorUrl": {
          "type": "string",
          "title": "url of OTEL collector - grpc"
        },
        "collectorKey": {
          "type": "string",
          "title": "send as x-stanza-key header"
        },
        "sampleRateDefault": {
          "type": "number",
          "format": "float",
          "title": "default base sampling rate"
        },
        "overrides": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1TraceConfigOverride"
          },
          "title": "span sampling rate overrides"
        },
        "headerSampleConfigs": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1HeaderTraceConfig"
          },
          "title": "which headers to capture"
        },
        "paramSampleConfigs": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ParamTraceConfig"
          },
          "title": "which parameters to capture"
        },
        "collectorUrlHttp": {
          "type": "string",
          "title": "url of OTEL collector - HTTP"
        }
      }
    },
    "v1TraceConfigOverride": {
      "type": "object",
      "properties": {
        "sampleRate": {
          "type": "number",
          "format": "float"
        },
        "spanSelectors": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1SpanSelector"
          }
        }
      },
      "description": "This configuration allows different sample rates to be applied to selected spans."
    },
    "v1ValidateTokenRequest": {
      "type": "object",
      "properties": {
        "tokens": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1TokenInfo"
          }
        }
      },
      "description": "Calls Hub to validate a token (ensures token has not expired, was minted by Hub, and related to the specified Decorator). Used from Ingress decorators. Ensures callers have acquired quota prior to expending resources."
    },
    "v1ValidateTokenResponse": {
      "type": "object",
      "properties": {
        "valid": {
          "type": "boolean",
          "title": "Unused, does not work in batch mode, will remove in V1 API"
        },
        "tokensValid": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1TokenValid"
          }
        }
      },
      "description": "Specifies whether tokens were valid or not."
    }
  },
  "securityDefinitions": {
    "ApiKeyAuth": {
      "type": "apiKey",
      "name": "X-Stanza-Key",
      "in": "header"
    }
  },
  "externalDocs": {
    "description": "Stanza Hub API",
    "url": "https://stanza.stoplight.io/docs/apis/291a2cff9d156-stanza-hub-api"
  }
}
